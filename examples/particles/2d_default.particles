(
    shader_source: Some((
        init: "#import bevy_hanabi::vfx_common::{\r\n    IndirectBuffer, ParticleGroup, RenderEffectMetadata, RenderGroupIndirect, SimParams, Spawner,\r\n    seed, tau, pcg_hash, to_float01, frand, frand2, frand3, frand4,\r\n    rand_uniform_f, rand_uniform_vec2, rand_uniform_vec3, rand_uniform_vec4,\r\n    rand_normal_f, rand_normal_vec2, rand_normal_vec3, rand_normal_vec4, proj\r\n}\r\n\r\nstruct Particle {\r\n    position: vec3<f32>,\n    age: f32,\n    velocity: vec3<f32>,\n    lifetime: f32,\n\r\n}\r\n\r\nstruct ParticleBuffer {\r\n    particles: array<Particle>,\r\n}\r\n\r\n\r\n\r\n@group(0) @binding(0) var<uniform> sim_params : SimParams;\r\n@group(1) @binding(0) var<storage, read_write> particle_buffer : ParticleBuffer;\r\n@group(1) @binding(1) var<storage, read_write> indirect_buffer : IndirectBuffer;\r\n@group(1) @binding(2) var<storage, read> particle_groups : array<ParticleGroup>;\r\n// (no properties)\r\n@group(2) @binding(0) var<storage, read_write> spawner : Spawner; // NOTE - same group as update\r\n@group(3) @binding(0) var<storage, read_write> render_effect_indirect : RenderEffectMetadata;\r\n@group(3) @binding(1) var<storage, read_write> render_group_indirect : RenderGroupIndirect;\r\n\r\nfn set_position_circle_D6F0AE08FCA4E38F(particle: ptr<function, Particle>) {\n    // Circle center\n    let c = vec3<f32>(0.,0.,0.);\n    // Circle basis\n    let n = vec3<f32>(0.,0.,1.);\n    let sign = step(0.0, n.z) * 2.0 - 1.0;\n    let a = -1.0 / (sign + n.z);\n    let b = n.x * n.y * a;\n    let tangent = vec3<f32>(1.0 + sign * n.x * n.x * a, sign * b, -sign * n.x);\n    let bitangent = vec3<f32>(b, sign + n.y * n.y * a, -n.y);\n    // Circle radius\n    let r = 0.05;\n    // Spawn random point on/in circle\n    let theta = frand() * tau;\n    let dir = tangent * cos(theta) + bitangent * sin(theta);\n    (*particle).position = c + r * dir;\n}fn set_velocity_circle_CEBDFF6C032F1985(transform: mat4x4<f32>, particle: ptr<function, Particle>) {\n    let delta = (*particle).position - (vec3<f32>(0.,0.,0.));\n    let radial = normalize(delta - dot(delta, vec3<f32>(0.,0.,1.)) * (vec3<f32>(0.,0.,1.)));\n    let radial_vec4 = transform * vec4<f32>(radial.xyz, 0.0);\n    (*particle).velocity = radial_vec4.xyz * (30.);\n}\r\n\r\n@compute @workgroup_size(64)\r\nfn main(@builtin(global_invocation_id) global_invocation_id: vec3<u32>) {\r\n    var index = global_invocation_id.x;\r\n\r\n    // Cap to max number of dead particles, copied from dead_count at the end of the\r\n    // previous iteration, and constant during this pass (unlike dead_count).\r\n    if (index >= render_effect_indirect.max_spawn) {\r\n        return;\r\n    }\r\n\r\n    // Cap to the actual number of spawning requested by CPU, since compute shaders run\r\n    // in workgroup_size(64) so more threads than needed are launched (rounded up to 64).\r\n    let spawn_count : u32 = u32(spawner.spawn);\r\n    if (index >= spawn_count) {\r\n        return;\r\n    }\r\n\r\n    // Recycle a dead particle from the first group\r\n    let base_index = particle_groups[0].effect_particle_offset;\r\n    let dead_index = atomicSub(&render_group_indirect.dead_count, 1u) - 1u;\r\n    index = indirect_buffer.indices[3u * (base_index + dead_index) + 2u];\r\n\r\n    // Update PRNG seed\r\n    seed = pcg_hash(index ^ spawner.seed);\r\n\r\n    // Spawner transform\r\n    let transform = transpose(\r\n        mat4x4(\r\n            spawner.transform[0],\r\n            spawner.transform[1],\r\n            spawner.transform[2],\r\n            vec4<f32>(0.0, 0.0, 0.0, 1.0)\r\n        )\r\n    );\r\n\r\n    // Initialize new particle\r\n    var particle = Particle();\r\n    set_position_circle_D6F0AE08FCA4E38F(&particle);\nset_velocity_circle_CEBDFF6C032F1985(transform, &particle);\nparticle.age = 0.;\nparticle.lifetime = 10.;\n\r\n\r\n    \r\n\r\n    // Count as alive\r\n    atomicAdd(&render_group_indirect.alive_count, 1u);\r\n\r\n    // Always write into ping, read from pong\r\n    let ping = render_effect_indirect.ping;\r\n\r\n    // Add to alive list\r\n    let indirect_index = atomicAdd(&render_group_indirect.instance_count, 1u);\r\n    indirect_buffer.indices[3u * (base_index + indirect_index) + ping] = index;\r\n\r\n    // Write back spawned particle\r\n    particle_buffer.particles[index] = particle;\r\n}\r\n",
        update: [
            "#import bevy_hanabi::vfx_common::{\r\n    IndirectBuffer, ParticleGroup, RenderEffectMetadata, RenderGroupIndirect, SimParams, Spawner,\r\n    seed, tau, pcg_hash, to_float01, frand, frand2, frand3, frand4,\r\n    rand_uniform_f, rand_uniform_vec2, rand_uniform_vec3, rand_uniform_vec4,\r\n    rand_normal_f, rand_normal_vec2, rand_normal_vec3, rand_normal_vec4, proj\r\n}\r\n\r\nstruct Particle {\r\n    position: vec3<f32>,\n    age: f32,\n    velocity: vec3<f32>,\n    lifetime: f32,\n\r\n}\r\n\r\nstruct ParticleBuffer {\r\n    particles: array<Particle>,\r\n}\r\n\r\n\r\n\r\n@group(0) @binding(0) var<uniform> sim_params : SimParams;\r\n@group(1) @binding(0) var<storage, read_write> particle_buffer : ParticleBuffer;\r\n@group(1) @binding(1) var<storage, read_write> indirect_buffer : IndirectBuffer;\r\n@group(1) @binding(2) var<storage, read> particle_groups : array<ParticleGroup>;\r\n// (no properties)\r\n@group(2) @binding(0) var<storage, read_write> spawner : Spawner; // NOTE - same group as init\r\n@group(3) @binding(0) var<storage, read_write> render_effect_indirect : RenderEffectMetadata;\r\n@group(3) @binding(1) var<storage, read_write> render_group_indirect : array<RenderGroupIndirect>;\r\n\r\n\r\n\r\n@compute @workgroup_size(64)\r\nfn main(@builtin(global_invocation_id) global_invocation_id: vec3<u32>) {\r\n    let thread_index = global_invocation_id.x;\r\n\r\n    // Cap at maximum number of particles.\r\n    // FIXME - This is probably useless given below cap\r\n    let max_particles : u32 = particle_groups[0].capacity;\r\n    if (thread_index >= max_particles) {\r\n        return;\r\n    }\r\n\r\n    // Cap at maximum number of alive particles.\r\n    if (thread_index >= render_group_indirect[0].max_update) {\r\n        return;\r\n    }\r\n\r\n    // Always write into ping, read from pong\r\n    let ping = render_effect_indirect.ping;\r\n    let pong = 1u - ping;\r\n\r\n    let effect_particle_offset = particle_groups[0].effect_particle_offset;\r\n    let base_index = effect_particle_offset + particle_groups[0].indirect_index;\r\n    let index = indirect_buffer.indices[3u * (base_index + thread_index) + pong];\r\n\r\n    var particle: Particle = particle_buffer.particles[index];\r\n\r\n    // Update PRNG seed\r\n    seed = pcg_hash(index ^ spawner.seed);\r\n\r\n    particle.age = particle.age + sim_params.delta_time;\n    var is_alive = particle.age < particle.lifetime;\r\n    \nparticle.position += particle.velocity * sim_params.delta_time;\n\r\n    is_alive = is_alive && (particle.age < particle.lifetime);\r\n\r\n    particle_buffer.particles[index] = particle;\r\n\r\n    // Check if alive\r\n    if (!is_alive) {\r\n        // Save dead index\r\n        let dead_index = atomicAdd(&render_group_indirect[0].dead_count, 1u);\r\n        indirect_buffer.indices[3u * (base_index + dead_index) + 2u] = index;\r\n        // Also increment copy of dead count, which was updated in dispatch indirect\r\n        // pass just before, and need to remain correct after this pass\r\n        atomicAdd(&render_effect_indirect.max_spawn, 1u);\r\n        atomicSub(&render_group_indirect[0].alive_count, 1u);\r\n    } else {\r\n        // Increment alive particle count and write indirection index for later rendering\r\n        let indirect_index = atomicAdd(&render_group_indirect[0].instance_count, 1u);\r\n        indirect_buffer.indices[3u * (base_index + indirect_index) + ping] = index;\r\n    }\r\n}\r\n",
        ],
        render: [
            "#import bevy_render::view::View\r\n#import bevy_hanabi::vfx_common::{\r\n    DispatchIndirect, IndirectBuffer, SimParams, Spawner,\r\n    seed, tau, pcg_hash, to_float01, frand, frand2, frand3, frand4,\r\n    rand_uniform_f, rand_uniform_vec2, rand_uniform_vec3, rand_uniform_vec4,\r\n    rand_normal_f, rand_normal_vec2, rand_normal_vec3, rand_normal_vec4, proj\r\n}\r\n\r\nstruct Particle {\r\n    position: vec3<f32>,\n    age: f32,\n    velocity: vec3<f32>,\n    lifetime: f32,\n\r\n}\r\n\r\nstruct ParticleBuffer {\r\n    particles: array<Particle>,\r\n}\r\n\r\nstruct VertexOutput {\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(0) color: vec4<f32>,\r\n#ifdef NEEDS_UV\r\n    @location(1) uv: vec2<f32>,\r\n#endif\r\n}\r\n\r\n@group(0) @binding(0) var<uniform> view: View;\r\n@group(0) @binding(1) var<uniform> sim_params : SimParams;\r\n@group(1) @binding(0) var<storage, read> particle_buffer : ParticleBuffer;\r\n@group(1) @binding(1) var<storage, read> indirect_buffer : IndirectBuffer;\r\n@group(1) @binding(2) var<storage, read> dispatch_indirect : DispatchIndirect;\r\n#ifdef RENDER_NEEDS_SPAWNER\r\n@group(1) @binding(3) var<storage, read> spawner : Spawner; // NOTE - same group as update\r\n#endif\r\n\r\n\r\nfn get_camera_position_effect_space() -> vec3<f32> {\r\n    let view_pos = view.world_from_view[3].xyz;\r\n#ifdef LOCAL_SPACE_SIMULATION\r\n    let inverse_transform = transpose(\r\n        mat3x3(\r\n            spawner.inverse_transform[0].xyz,\r\n            spawner.inverse_transform[1].xyz,\r\n            spawner.inverse_transform[2].xyz,\r\n        )\r\n    );\r\n    return inverse_transform * view_pos;\r\n#else\r\n    return view_pos;\r\n#endif\r\n}\r\n\r\nfn get_camera_rotation_effect_space() -> mat3x3<f32> {\r\n    let view_rot = mat3x3(view.world_from_view[0].xyz, view.world_from_view[1].xyz, view.world_from_view[2].xyz);\r\n#ifdef LOCAL_SPACE_SIMULATION\r\n    let inverse_transform = transpose(\r\n        mat3x3(\r\n            spawner.inverse_transform[0].xyz,\r\n            spawner.inverse_transform[1].xyz,\r\n            spawner.inverse_transform[2].xyz,\r\n        )\r\n    );\r\n    return inverse_transform * view_rot;\r\n#else\r\n    return view_rot;\r\n#endif\r\n}\r\n\r\n/// Unpack a compressed transform stored in transposed row-major form.\r\nfn unpack_compressed_transform(compressed_transform: mat3x4<f32>) -> mat4x4<f32> {\r\n    return transpose(\r\n        mat4x4(\r\n            compressed_transform[0],\r\n            compressed_transform[1],\r\n            compressed_transform[2],\r\n            vec4<f32>(0.0, 0.0, 0.0, 1.0)\r\n        )\r\n    );\r\n}\r\n\r\n/// Transform a simulation space position into a world space position.\r\n///\r\n/// The simulation space depends on the effect\'s SimulationSpace value, and is either\r\n/// the effect space (SimulationSpace::Local) or the world space (SimulationSpace::Global).\r\nfn transform_position_simulation_to_world(sim_position: vec3<f32>) -> vec4<f32> {\r\n#ifdef LOCAL_SPACE_SIMULATION\r\n    let transform = unpack_compressed_transform(spawner.transform);\r\n    return transform * vec4<f32>(sim_position, 1.0);\r\n#else\r\n    return vec4<f32>(sim_position, 1.0);\r\n#endif\r\n}\r\n\r\n/// Transform a simulation space position into a clip space position.\r\n///\r\n/// The simulation space depends on the effect\'s SimulationSpace value, and is either\r\n/// the effect space (SimulationSpace::Local) or the world space (SimulationSpace::Global).\r\n/// The clip space is the final [-1:1]^3 space output from the vertex shader, before\r\n/// perspective divide and viewport transform are applied.\r\nfn transform_position_simulation_to_clip(sim_position: vec3<f32>) -> vec4<f32> {\r\n    return view.clip_from_world * transform_position_simulation_to_world(sim_position);\r\n}\r\n\r\nfn size_gradient_AE5DA34C4A955C26(key: f32) -> vec2<f32> {\n    // Gradient\nlet t0 = 0.;\nlet v0 = vec2<f32>(2.,2.);\nreturn v0;\n\n}\n\n\r\n\r\n@vertex\r\nfn vertex(\r\n    @builtin(instance_index) instance_index: u32,\r\n    @location(0) vertex_position: vec3<f32>,\r\n#ifdef NEEDS_UV\r\n    @location(1) vertex_uv: vec2<f32>,\r\n#endif\r\n    // @location(1) vertex_color: u32,\r\n    // @location(1) vertex_velocity: vec3<f32>,\r\n) -> VertexOutput {\r\n    let pong = dispatch_indirect.pong;\r\n    let index = indirect_buffer.indices[3u * instance_index + pong];\r\n    var particle = particle_buffer.particles[index];\r\n    var out: VertexOutput;\r\n#ifdef NEEDS_UV\r\n    var uv = vertex_uv;\r\n#ifdef FLIPBOOK\r\n    let row_count = ;\r\n    let ij = vec2<f32>(f32(particle.sprite_index % row_count), f32(particle.sprite_index / row_count));\r\n    uv = (ij + uv) * ;\r\n#endif\r\n    out.uv = uv;\r\n#endif  // NEEDS_UV\r\n\r\nvar position = particle.position;\nvar age = particle.age;\nvar velocity = particle.velocity;\nvar lifetime = particle.lifetime;\nvar size = vec2<f32>(1.,1.);\nvar color = vec4<f32>(1.,1.,1.,1.);\nvar axis_y = vec3<f32>(0.,1.,0.);\nvar axis_x = vec3<f32>(1.,0.,0.);\nvar axis_z = vec3<f32>(0.,0.,1.);\n\r\n\r\nsize = size_gradient_AE5DA34C4A955C26(particle.age / particle.lifetime);\naxis_x = normalize(particle.velocity);\naxis_y = cross(axis_z, axis_x);\n\r\n\r\n    // Expand particle mesh vertex based on particle position (\"origin\"), and local\r\n    // orientation and size of the particle mesh (currently: only quad).\r\n    let vpos = vertex_position * vec3<f32>(size.x, size.y, 1.0);\r\n    let sim_position = position + axis_x * vpos.x + axis_y * vpos.y;\r\n    out.position = transform_position_simulation_to_clip(sim_position);\r\n\r\n    out.color = color;\r\n\r\n    return out;\r\n}\r\n\r\n@fragment\r\nfn fragment(in: VertexOutput) -> @location(0) vec4<f32> {\r\n\r\n#ifdef USE_ALPHA_MASK\r\n    var alpha_cutoff: f32 = ;\r\n#endif\r\n    var color = in.color;\r\n#ifdef NEEDS_UV\r\n    var uv = in.uv;\r\n#endif\r\n\r\n\r\n\r\n#ifdef USE_ALPHA_MASK\r\n    if color.a >= alpha_cutoff {\r\n        color.a = 1.0;\r\n    } else {\r\n        discard;\r\n    }\r\n#endif\r\n\r\n    return color;\r\n}",
        ],
        export: [
            "#import bevy_hanabi::vfx_common::{\r\n    IndirectBuffer, ParticleGroup, RenderEffectMetadata, RenderGroupIndirect, SimParams, Spawner,\r\n    seed, tau, pcg_hash, to_float01, frand, frand2, frand3, frand4,\r\n    rand_uniform_f, rand_uniform_vec2, rand_uniform_vec3, rand_uniform_vec4, proj\r\n}\r\n\r\n//at most 256 particle groups are supported\r\nconst WG_SIZE = 256u;\r\nconst EXPORT_SIZE = 8u;\r\n\r\nstruct Particle {\r\n    position: vec3<f32>,\n    age: f32,\n    velocity: vec3<f32>,\n    lifetime: f32,\n\r\n}\r\n\r\nstruct ParticleBuffer {\r\n    particles: array<Particle>,\r\n}\r\n\r\n\r\n\r\n@group(0) @binding(0) var<storage, read_write> export_buffer : array<u32>;\r\n@group(0) @binding(1) var<uniform> uniform_index_input : u32;\r\n@group(1) @binding(0) var<storage, read_write> particle_buffer : ParticleBuffer;\r\n@group(1) @binding(1) var<storage, read_write> indirect_buffer : IndirectBuffer;\r\n@group(1) @binding(2) var<storage, read> particle_groups : array<ParticleGroup>;\r\n// (no properties)\r\n@group(2) @binding(0) var<storage, read_write> render_effect_indirect : RenderEffectMetadata;\r\n@group(2) @binding(1) var<storage, read_write> render_group_indirect : array<RenderGroupIndirect>;\r\n\r\n\r\nfn get_camera_position_effect_space() -> vec3<f32> {{ return vec3<f32>(); }}\r\nfn get_camera_rotation_effect_space() -> mat3x3<f32> {{ return mat3x3<f32>(); }}\r\n\r\nfn size_gradient_AE5DA34C4A955C26(key: f32) -> vec2<f32> {\n    // Gradient\nlet t0 = 0.;\nlet v0 = vec2<f32>(2.,2.);\nreturn v0;\n\n}\n\n\r\n\r\n@compute @workgroup_size(64)\r\nfn main(@builtin(global_invocation_id) global_invocation_id: vec3<u32>) {\r\n    let thread_index = global_invocation_id.x;\r\n    let uniform_index = uniform_index_input >> 6u;\r\n    let start = select( export_buffer[uniform_index - 1u], 0u, uniform_index == 0u);\r\n    let thread_size = atomicLoad(&render_group_indirect[0].alive_count);\r\n    export_buffer[uniform_index] = start + thread_size;\r\n\r\n    if thread_index >= thread_size {\r\n        return;\r\n    }\r\n\r\n    // Always write into ping, read from pong\r\n    let ping = render_effect_indirect.ping;\r\n\r\n    let effect_particle_offset = particle_groups[0].effect_particle_offset;\r\n    let base_index = effect_particle_offset + particle_groups[0].indirect_index;\r\n    let particle_index = indirect_buffer.indices[3u * (base_index + thread_index) + ping];\r\n\r\n    var particle: Particle = particle_buffer.particles[particle_index];\r\n\r\nvar position = particle.position;\nvar age = particle.age;\nvar velocity = particle.velocity;\nvar lifetime = particle.lifetime;\nvar size = vec2<f32>(1.,1.);\nvar color = vec4<f32>(1.,1.,1.,1.);\nvar axis_y = vec3<f32>(0.,1.,0.);\nvar axis_x = vec3<f32>(1.,0.,0.);\nvar axis_z = vec3<f32>(0.,0.,1.);\n\r\n\r\nsize = size_gradient_AE5DA34C4A955C26(particle.age / particle.lifetime);\naxis_x = normalize(particle.velocity);\naxis_y = cross(axis_z, axis_x);\n\r\n\r\n    var export_index = WG_SIZE + (start + thread_index) * EXPORT_SIZE;\r\n    export_buffer[export_index] = bitcast<u32>(axis_x.x * size.x);\r\n    export_buffer[export_index + 1u] = bitcast<u32>(axis_x.y * size.x);\r\n    export_buffer[export_index + 2u] = bitcast<u32>(axis_y.x * size.y);\r\n    export_buffer[export_index + 3u] = bitcast<u32>(axis_y.y * size.y);\r\n    export_buffer[export_index + 4u] = bitcast<u32>(position.x);\r\n    export_buffer[export_index + 5u] = bitcast<u32>(position.y);\r\n}\r\n",
        ],
        layout_flags: ("LOCAL_SPACE_SIMULATION"),
    )),
    particle_layout: (
        layout: [
            (
                attribute: "position",
                offset: 0,
            ),
            (
                attribute: "age",
                offset: 12,
            ),
            (
                attribute: "velocity",
                offset: 16,
            ),
            (
                attribute: "lifetime",
                offset: 28,
            ),
        ],
    ),
    name: "2d_default",
    capacities: [
        2048,
    ],
    spawner: (
        num_particles: Single(30.0),
        spawn_time: Single(1.0),
        period: Single(1.0),
        starts_active: true,
        starts_immediately: true,
    ),
    z_layer_2d: 0.0,
    simulation_space: Local,
    simulation_condition: WhenVisible,
    motion_integration: PostUpdate,
    module: (
        expressions: [
            Literal(Scalar(Float(0.0))),
            Literal(Scalar(Float(10.0))),
            Literal(Vector(Vec3((0.0, 0.0, 0.0)))),
            Literal(Vector(Vec3((0.0, 0.0, 1.0)))),
            Literal(Scalar(Float(0.05))),
            Literal(Vector(Vec3((0.0, 0.0, 0.0)))),
            Literal(Vector(Vec3((0.0, 0.0, 1.0)))),
            Literal(Scalar(Float(30.0))),
        ],
        properties: [],
        texture_layout: (
            layout: [],
        ),
    ),
    alpha_mode: Blend,
)